树存储方式分析
    能够提高数据存储，读取的效率，比如利用二叉排序树BST，既可以保证数据的检索速度，
同时也可以保证数据的插入，删除，修改的速度。
二叉树
    节点，根节点，父节点，子节点，叶子节点，节点的权
    路径(root节点到该节点的path)，层，子树，树的高度，森林
    每个节点最多只能有两个子节点的树称为二叉树
前序中序与后序遍历
    前序遍历：先输出父节点，再输出左子树和右子树
        1.创建一颗二叉树
        2.先输出当前节点（出事的时候是root节点）
        3.如果左子节点不为空，则递归继续前序遍历
        4.如果右子节点不为空，则递归继续前序遍历
    中序遍历：先遍历左子树，再输出父节点，再遍历右子树
        1.创建一颗二叉树
        2.如果当前节点左子节点不为空，则递归中序遍历
        3.输出当前节点
        4.如果当前节点右子节点不为空，则递归中序遍历
    后序遍历：先遍历左子树，再遍历右子树，再输出父节点
        1.创建一颗二叉树
        2.如果当前节点左子节点不为空，则递归后序遍历
        3.如果当前节点右子节点不为空，则递归后序遍历
        4.输出当前节点
前序中序与后序查找
    前序查找：
        1.先判断当前结点的no是否等于要查找的
        2.如果相等，则返回当前结点
        3.如果不等，则判断当前结点的左子结点是否为空，如果不为空，则递归前序查找
        4.如果左递归前序查找，找到结点则返回，否则继续判断，当前结点的右子结点是否为空，如果不空，则继续向右递归前序查找
    中序查找
        1.判断当前结点的左子结点是否为空，如果不为空，则递归中序查找
        2.如果找到，则返回，如果没有找到，则与当前结点进行比较，如果是则返回当前结点，否则继续进行右递归的中序查找
        3.如果右递归中序查找，找到则返回，否则返回null
    后序查找
        1.判断当前结点的左子结点是否为空，如果不为空，则递归后序查找
        2.如果找到，则返回，如果没有找到，就判断当前结点的右子结点是否为空，如果不为空，则右递归进行后序查找，如果找到就返回
        3.和当前结点进行比较，如果是则返回，否则返回null
结点的删除
    删除思路
    1.如果树是空树，或者树只有一个root结点，则等价于将二叉树置空
    2.因为二叉树是单向的，所以需要判断当前结点的子结点是否需要删除
    3.如果当前结点的左子结点不为空，并且左子结点就是要删除的结点，就将this->left=nullptr;并且结束递归
    4.如果当前结点的右子结点不为空，并且右子结点就是要删除的结点，就将this->right=nullptr;并且结束递归
    5.如果前两步都没有删除结点，那就需要向左子树进行递归删除，如果左子树仍未成功，则递归向右子树进行删除